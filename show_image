#!/usr/bin/env python
# Import ROS libraries and messages
import rospy
from sensor_msgs.msg import Image
from sensor_msgs.msg import LaserScan
import numpy
# Import OpenCV libraries and tools
import cv2
from cv_bridge import CvBridge, CvBridgeError
from collections import deque
import numpy as np
import argparse
import cv2
import imutils
import time
import pandas as pd
import time


# define the lower and upper boundaries of the "blue"
BlueLower = (100, 150, 0)
BlueUpper = (140,255,255)

DISTANCEUpper = 2
DISTANCELower = 1


RedLower = (0,50,50)
RedUppder = (10,255,255)


RAD_MAX = 350
RAD_MIN = 200

PIXSELS_TO_BIG_BALL = 30
PIXSELS_TO_BIG_BALL_LOWER = 50
PIXSELS_TO_BIG_BALL_UPPER = 150
class Ball_Identification:

    def __init__(self):
        # Initialize the ROS Node named 'opencv_example', allow multiple nodes to be run with this name
        rospy.init_node('opencv_example', anonymous=True)

        # Print "Hello ROS!" to the Terminal and to a ROS Log file located in ~/.ros/log/loghash/*.log
        # rospy.loginfo("Hello ROS!")

        sub_image = rospy.Subscriber("/camera/rgb/image_raw", Image, self.image_callback)

        sub_leaser = rospy.Subscriber('/scan', LaserScan, self.scan_callback)


        self.suspicious_of_ball_in_front = False

        cv2.namedWindow("Image Window", 1)

    def show_image(self,img):
        cv2.imshow("Image Window", img)
        cv2.waitKey(3)

    def show_red(self):
        pass

    def image_callback(self,img_msg):
        # log some info about the image topic
        # rospy.loginfo(img_msg.header)

        image = bridge.imgmsg_to_cv2(img_msg, "passthrough")

        # resize the image
        image = imutils.resize(image, width=1800)
        # Converts an image from one color space to another
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        self.blurred = cv2.GaussianBlur(image, (11, 11), 0)

        # find the red images
        image = self.find_circle(image, "red")

        # find the blue image
        image = self.find_circle(image, "blue")

        # diplay more ditles
        

        self.show_image(image)

    def scan_callback(self,msg):

        ranges = msg.ranges
        pixel_counter = 1

        # calculate right from middle
        i = 359
        while (abs(ranges[i] - ranges[i - 1]) < 1 and i > 290):
            i = i - 1
            pixel_counter += 1

        # calculate left from middle
        i = 0
        while (abs(ranges[i] - ranges[i + 1]) < 1 and i < 70):
            i = i + 1

            pixel_counter += 1


        distanse = (ranges[0] + ranges[1] + ranges[-1])/3

        rospy.loginfo(pixel_counter)
        rospy.loginfo(distanse)

        if PIXSELS_TO_BIG_BALL_UPPER >= pixel_counter and pixel_counter >= PIXSELS_TO_BIG_BALL_LOWER  and distanse <=2:
            self.suspicious_of_ball_in_front = True

        else:
            self.suspicious_of_ball_in_front = False



    def find_circle(self,image,ball_color):

        # add gaussian blur


        # image = cv2.cvtColor( image, cv2.COLOR_BGR2RGB)


        hsv = cv2.cvtColor(self.blurred, cv2.COLOR_BGR2HSV)

        if ball_color == 'blue':
            colorUpper  = BlueUpper
            colorLower =  BlueLower
        else:
            colorUpper = RedUppder
            colorLower = RedLower
        msk = cv2.inRange(hsv, colorLower, colorUpper)
        msk = cv2.erode(msk, None, iterations=2)
        msk = cv2.dilate(msk, None, iterations=2)
        # find the blue image

        # find contours in the mask and initialize the current
        # (x, y) center of the ball
        cnts = cv2.findContours(msk.copy(), cv2.RETR_EXTERNAL,
                                cv2.CHAIN_APPROX_SIMPLE)

        cnts = imutils.grab_contours(cnts)

        if len(cnts) > 0:
            # find the largest contour in the mask, then use
            # it to compute the minimum enclosing circle and
            # centroid
            c = max(cnts, key=cv2.contourArea)
            ((x, y), radius) = cv2.minEnclosingCircle(c)
            M = cv2.moments(c)
            center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
            # only proceed if the radius meets a minimum size
            # if radius > RAD_MIN and radius < RAD_MAX:
            if self.suspicious_of_ball_in_front:
                # draw the circle and centroid on the frame,
                # then update the list of tracked points
                cv2.circle(image, (int(x), int(y)), int(radius),
                               (0, 255, 255), 2)
                cv2.circle(image, center, 5, (0, 0, 255), -1)

                font = cv2.FONT_HERSHEY_SIMPLEX

                fontScale = 1
                if ball_color =='blue':
                    color = (255, 0, 0)
                    org = (200, 200)
                else:
                    color = (0, 0, 255)
                    org = (100, 200)
                thickness = 2
                image = cv2.putText(image,ball_color, org, font,
                                        fontScale, color, thickness, cv2.LINE_AA)


        return image





if __name__ == '__main__':


    # Initialize the CvBridge class
    bridge = CvBridge()

    start = time.time()

    bi = Ball_Identification()

    # Loop to keep the program from shutting down unless ROS is shut down, or CTRL+C is pressed
    while not rospy.is_shutdown():
        rospy.spin()

    # Define a function to show the image in an OpenCV Window

